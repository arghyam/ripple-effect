export interface TokenValue<T = unknown> {
    /**
     * @description Token type.
     */
    __t: T;
    /**
     * @description Description of token.
     */
    __d: string;
    /**
     * @description Unique symbol.
     */
    __s: symbol;
    /**
     * @description Is binding by token optional.
     */
    __o: boolean;
}
export interface RequiredToken<T = unknown> extends TokenValue<T> {
    __o: false;
}
export interface OptionalToken<T = unknown> extends TokenValue<T> {
    __o: true;
}
export interface Token<T = unknown> extends RequiredToken<T> {
    optional: OptionalToken<T>;
}
export declare type TokenType<T extends TokenValue> = T extends RequiredToken ? T['__t'] : T['__t'] | undefined;
export declare type TokenTypeMap<T> = {
    [K in keyof T]: T[K] extends Token ? TokenType<T[K]> : TokenTypeMap<T[K]>;
};
export declare type ToToken<T> = undefined extends T ? OptionalToken<Exclude<T, undefined>> : RequiredToken<T>;
/**
 * @description
 * Creates a unique token with the type.
 *
 * @param {string} description - a description of the token to be used in logs and error messages.
 * @returns a unique `Token<T>` token with the type.
 *
 * @link https://brandi.js.org/reference/pointers-and-registrators#tokentdescription
 */
export declare const token: <T>(description: string) => Token<T>;
