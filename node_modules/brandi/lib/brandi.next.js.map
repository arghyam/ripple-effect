{
  "version": 3,
  "sources": ["../src/registries/callableRegistry.ts", "../src/registries/injectsRegistry.ts", "../src/registries/tagsRegistry.ts", "../src/container/bindings/Binding.ts", "../src/container/bindings/ConstantBinding.ts", "../src/container/bindings/FactoryBinding.ts", "../src/container/bindings/InstanceBinding.ts", "../src/pointers/tag.ts", "../src/pointers/token.ts", "../src/container/BindingsVault.ts", "../src/container/syntax/FromSyntax.ts", "../src/container/syntax/ScopeSyntax.ts", "../src/container/syntax/TypeSyntax.ts", "../src/container/syntax/BindOrUseSyntax.ts", "../src/container/syntax/WhenSyntax.ts", "../src/container/DependencyModule.ts", "../src/container/ResolutionCache.ts", "../src/container/Container.ts", "../src/container/createContainer.ts", "../src/container/createDependencyModule.ts", "../src/registrators/injected.ts", "../src/registrators/tagged.ts"],
  "sourcesContent": ["import { UnknownCreator } from '../types';\n\nexport const callableRegistry = new WeakMap<UnknownCreator, boolean>();\n", "import { TokenValue } from '../pointers';\nimport { UnknownCreator } from '../types';\n\nexport const injectsRegistry = new Map<UnknownCreator, TokenValue[]>();\n", "import { Tag } from '../pointers';\nimport { UnknownCreator } from '../types';\n\nexport const tagsRegistry = new Map<UnknownCreator, Tag[]>();\n", "export enum Type {\n  Constant,\n  Instance,\n  Factory,\n}\n\nexport enum Scope {\n  Container,\n  Resolution,\n  Singleton,\n  Transient,\n}\n\nexport interface Binding {\n  readonly impl: unknown;\n  readonly type: Type;\n\n  clone?: () => Binding;\n}\n", "import { Binding, Type } from './Binding';\n\nexport class ConstantBinding implements Binding {\n  public readonly type = Type.Constant;\n\n  constructor(public readonly impl: unknown) {}\n}\n", "import { UnknownCreator } from '../../types';\n\nimport { Binding, Type } from './Binding';\n\nexport type FactoryInitializer = (\n  instance: unknown,\n  ...args: unknown[]\n) => unknown;\n\nexport class FactoryBinding implements Binding {\n  public readonly type = Type.Factory;\n\n  constructor(\n    public readonly impl: {\n      creator: UnknownCreator;\n      initializer?: FactoryInitializer;\n    },\n  ) {}\n}\n\nexport const isFactoryBinding = (binding: Binding): binding is FactoryBinding =>\n  binding.type === Type.Factory;\n", "import { UnknownCreator } from '../../types';\n\nimport type { BindingsVault } from '../BindingsVault';\n\nimport { Binding, Scope, Type } from './Binding';\n\nexport abstract class InstanceBinding implements Binding {\n  public readonly type = Type.Instance;\n\n  public abstract readonly scope: Scope;\n\n  constructor(public readonly impl: UnknownCreator) {}\n}\n\nexport class InstanceContainerScopedBinding extends InstanceBinding {\n  public readonly scope = Scope.Container;\n\n  public readonly cache = new WeakMap<BindingsVault, unknown>();\n}\n\nexport class InstanceResolutionScopedBinding extends InstanceBinding {\n  public readonly scope = Scope.Resolution;\n}\n\nexport class InstanceSingletonScopedBinding extends InstanceBinding {\n  public readonly scope = Scope.Singleton;\n\n  public cache?: unknown;\n\n  public clone?(): InstanceSingletonScopedBinding;\n\n  constructor(public readonly impl: UnknownCreator) {\n    super(impl);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.clone = (): InstanceSingletonScopedBinding => {\n        const binding = new InstanceSingletonScopedBinding(this.impl);\n        binding.cache = this.cache;\n        return binding;\n      };\n    }\n  }\n}\n\nexport class InstanceTransientScopedBinding extends InstanceBinding {\n  public readonly scope = Scope.Transient;\n}\n\nexport const isInstanceBinding = (\n  binding: Binding,\n): binding is InstanceBinding => binding.type === Type.Instance;\n\nexport const isInstanceContainerScopedBinding = (\n  binding: InstanceBinding,\n): binding is InstanceContainerScopedBinding =>\n  binding.scope === Scope.Container;\n\nexport const isInstanceResolutionScopedBinding = (\n  binding: InstanceBinding,\n): binding is InstanceResolutionScopedBinding =>\n  binding.scope === Scope.Resolution;\n\nexport const isInstanceSingletonScopedBinding = (\n  binding: InstanceBinding,\n): binding is InstanceSingletonScopedBinding =>\n  binding.scope === Scope.Singleton;\n", "export type Tag = symbol & { __tag__: true };\n\n/**\n * @description\n * Creates a unique tag.\n *\n * @param {string} description - a description of the tag to be used in logs and error messages.\n * @returns `Tag`.\n *\n * @link https://brandi.js.org/reference/pointers-and-registrators#tagdescription\n */\nexport const tag = (description: string): Tag => Symbol(description) as Tag;\n", "export interface TokenValue<T = unknown> {\n  /**\n   * @description Token type.\n   */\n  __t: T;\n\n  /**\n   * @description Description of token.\n   */\n  __d: string;\n\n  /**\n   * @description Unique symbol.\n   */\n\n  __s: symbol;\n\n  /**\n   * @description Is binding by token optional.\n   */\n  __o: boolean;\n}\n\nexport interface RequiredToken<T = unknown> extends TokenValue<T> {\n  __o: false;\n}\n\nexport interface OptionalToken<T = unknown> extends TokenValue<T> {\n  __o: true;\n}\n\nexport interface Token<T = unknown> extends RequiredToken<T> {\n  optional: OptionalToken<T>;\n}\n\nexport type TokenType<T extends TokenValue> = T extends RequiredToken\n  ? T['__t']\n  : T['__t'] | undefined;\n\nexport type TokenTypeMap<T> = {\n  [K in keyof T]: T[K] extends Token ? TokenType<T[K]> : TokenTypeMap<T[K]>;\n};\n\nexport type ToToken<T> = undefined extends T\n  ? OptionalToken<Exclude<T, undefined>>\n  : RequiredToken<T>;\n\n/**\n * @description\n * Creates a unique token with the type.\n *\n * @param {string} description - a description of the token to be used in logs and error messages.\n * @returns a unique `Token<T>` token with the type.\n *\n * @link https://brandi.js.org/reference/pointers-and-registrators#tokentdescription\n */\nexport const token = <T>(description: string): Token<T> => {\n  const s = Symbol(description);\n  return {\n    __t: (null as unknown) as T,\n    __d: description,\n    __s: s,\n    __o: false,\n    optional: {\n      __t: (null as unknown) as T,\n      __d: description,\n      __s: s,\n      __o: true,\n    },\n  };\n};\n", "import { ResolutionCondition, UnknownCreator } from '../types';\nimport { Token, TokenValue, tag as createTag } from '../pointers';\n\nimport { Binding } from './bindings';\nimport { ResolutionCache } from './ResolutionCache';\n\ntype BindingsMap = Map<ResolutionCondition, Binding | BindingsVault>;\n\nexport class BindingsVault {\n  private static notag = createTag('NO_TAG');\n\n  public parent: BindingsVault | null = null;\n\n  private readonly map = new Map<symbol, BindingsMap>();\n\n  public copy?(): BindingsVault;\n\n  constructor() {\n    if (process.env.NODE_ENV !== 'production') {\n      this.copy = (): BindingsVault =>\n        this.from((prev) => {\n          const next = new Map<ResolutionCondition, Binding | BindingsVault>();\n          prev.forEach((binding, key) => {\n            if (binding instanceof BindingsVault) {\n              next.set(key, binding.copy!());\n            } else {\n              next.set(key, binding.clone?.() ?? binding);\n            }\n          });\n          return next;\n        });\n    }\n  }\n\n  public set(\n    binding: Binding | BindingsVault,\n    token: Token,\n    condition: ResolutionCondition = BindingsVault.notag,\n  ): void {\n    const current = this.map.get(token.__s);\n\n    if (current) current.set(condition, binding);\n    else\n      this.map.set(\n        token.__s,\n        new Map<ResolutionCondition, Binding | BindingsVault>().set(\n          condition,\n          binding,\n        ),\n      );\n  }\n\n  private find(\n    token: TokenValue,\n    conditions?: ResolutionCondition[],\n    target?: UnknownCreator,\n  ): Binding | BindingsVault | undefined {\n    const bindings = this.map.get(token.__s);\n\n    if (bindings === undefined) return undefined;\n\n    if (target) {\n      const targetBinding = bindings.get(target);\n      if (targetBinding) return targetBinding;\n    }\n\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      conditions &&\n      conditions.reduce(\n        (acc, condition) => (bindings.has(condition) ? acc + 1 : acc),\n        0,\n      ) > 1\n    ) {\n      const conditionsDisplayString = conditions\n        .map((condition) =>\n          typeof condition === 'function'\n            ? condition.name\n            : `tag(${condition.description})`,\n        )\n        .join(', ');\n\n      console.warn(\n        'Warning: ' +\n          `When resolving a binding by '${token.__d}' token with [${conditionsDisplayString}] conditions, ` +\n          'more than one binding was found. ' +\n          \"In this case, Brandi resolves the binding by the first tag assigned by 'tagged(target, ...tags)' function \" +\n          \"or, if you explicitly passed conditions through 'Container.get(token, conditions)' method, \" +\n          'by the first resolved condition. ' +\n          'Try to avoid such implicit logic.',\n      );\n    }\n\n    if (conditions) {\n      for (let i = 0, len = conditions.length; i < len; i += 1) {\n        const binding = bindings.get(conditions[i]!);\n        if (binding) return binding;\n      }\n    }\n\n    return bindings.get(BindingsVault.notag);\n  }\n\n  private resolve(\n    token: TokenValue,\n    cache: ResolutionCache,\n    conditions?: ResolutionCondition[],\n    target?: UnknownCreator,\n  ): Binding | null {\n    const binding = this.find(token, conditions, target);\n\n    if (binding === undefined)\n      return this.parent\n        ? this.parent.resolve(token, cache, conditions, target)\n        : null;\n\n    if (binding instanceof BindingsVault) {\n      cache.vaults.push(binding);\n      return binding.resolve(token, cache, conditions, target);\n    }\n\n    return binding;\n  }\n\n  public get(\n    token: TokenValue,\n    cache: ResolutionCache,\n    conditions?: ResolutionCondition[],\n    target?: UnknownCreator,\n  ): Binding | null {\n    const ownBinding = this.resolve(token, cache, conditions, target);\n\n    if (ownBinding) return ownBinding;\n\n    for (let i = 0, v = cache.vaults, len = v.length; i < len; i += 1) {\n      const cacheBinding = v[i]!.resolve(token, cache, conditions, target);\n      if (cacheBinding) return cacheBinding;\n    }\n\n    return null;\n  }\n\n  private from(\n    callback: (bindings: BindingsMap) => BindingsMap,\n  ): BindingsVault {\n    const vault = new BindingsVault();\n    vault.parent = this.parent;\n\n    this.map.forEach((bindings, key) => {\n      vault.map.set(key, callback(bindings));\n    });\n\n    return vault;\n  }\n\n  public clone(): BindingsVault {\n    return this.from(\n      (prev) => new Map<ResolutionCondition, Binding | BindingsVault>(prev),\n    );\n  }\n}\n", "import { ResolutionCondition } from '../../types';\nimport { Token } from '../../pointers';\n\nimport { BindingsVault } from '../BindingsVault';\nimport type { DependencyModule } from '../DependencyModule';\n\nimport type { BindOrUseSyntax } from './BindOrUseSyntax';\n\nexport class FromSyntax {\n  constructor(\n    private readonly vault: BindingsVault,\n    private readonly tokens: Token[],\n    private readonly getVault: (target: BindOrUseSyntax) => BindingsVault,\n    private readonly condition?: ResolutionCondition,\n  ) {}\n\n  /**\n   * @description\n   * Uses bindings from the dependency module.\n   *\n   * @param dependencyModule - the dependency module from which the tokens will be used.\n   *\n   * @link https://brandi.js.org/reference/container#usetokensfrommodule\n   */\n  public from(dependencyModule: DependencyModule): void {\n    const { tokens } = this;\n    for (let i = 0, len = tokens.length; i < len; i += 1) {\n      this.vault.set(\n        this.getVault(dependencyModule),\n        tokens[i]!,\n        this.condition,\n      );\n    }\n  }\n}\n", "import { ResolutionCondition, UnknownCreator } from '../../types';\nimport { Token } from '../../pointers';\n\nimport {\n  InstanceContainerScopedBinding,\n  InstanceResolutionScopedBinding,\n  InstanceSingletonScopedBinding,\n  InstanceTransientScopedBinding,\n} from '../bindings';\nimport { BindingsVault } from '../BindingsVault';\n\nexport class ScopeSyntax {\n  private readonly warningTimeout?: NodeJS.Timeout;\n\n  constructor(\n    private readonly vault: BindingsVault,\n    private readonly impl: UnknownCreator,\n    private readonly token: Token,\n    private readonly condition?: ResolutionCondition,\n  ) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.warningTimeout = setTimeout(() => {\n        console.warn(\n          `Warning: did you forget to set a scope for '${this.token.__d}' token binding? ` +\n            \"Call 'inTransientScope()', 'inSingletonScope()', 'inContainerScope()' or 'inResolutionScope()'.\",\n        );\n      });\n    }\n  }\n\n  /**\n   * @description\n   * The container will return the same instance with each getting.\n   * This is similar to being a singleton, however if the container has a child container or a clone,\n   * that child container or clone will get an instance unique to it.\n   *\n   * @link https://brandi.js.org/reference/binding-scopes#incontainerscope\n   */\n  public inContainerScope(): void {\n    this.set(InstanceContainerScopedBinding);\n  }\n\n  /**\n   * @description\n   * The same instance will be got for each getting of this dependency during a single resolution chain.\n   *\n   * @link https://brandi.js.org/reference/binding-scopes#inresolutionscope\n   */\n  public inResolutionScope(): void {\n    this.set(InstanceResolutionScopedBinding);\n  }\n\n  /**\n   * @description\n   * Each getting will return the same instance.\n   *\n   * @link https://brandi.js.org/reference/binding-scopes#insingletonscope\n   */\n  public inSingletonScope(): void {\n    this.set(InstanceSingletonScopedBinding);\n  }\n\n  /**\n   * @description\n   * New instance will be created with each getting.\n   *\n   * @link https://brandi.js.org/reference/binding-scopes#intransientscope\n   */\n  public inTransientScope(): void {\n    this.set(InstanceTransientScopedBinding);\n  }\n\n  private set(\n    Ctor:\n      | typeof InstanceContainerScopedBinding\n      | typeof InstanceResolutionScopedBinding\n      | typeof InstanceSingletonScopedBinding\n      | typeof InstanceTransientScopedBinding,\n  ): void {\n    if (process.env.NODE_ENV !== 'production')\n      clearTimeout(this.warningTimeout!);\n\n    this.vault.set(new Ctor(this.impl), this.token, this.condition);\n  }\n}\n", "import {\n  AsyncFactory,\n  Factory,\n  ResolutionCondition,\n  UnknownCreator,\n} from '../../types';\nimport { Token } from '../../pointers';\n\nimport {\n  ConstantBinding,\n  FactoryBinding,\n  FactoryInitializer,\n} from '../bindings';\nimport { BindingsVault } from '../BindingsVault';\n\nimport { ScopeSyntax } from './ScopeSyntax';\n\nexport class TypeSyntax<Dependency> {\n  constructor(\n    private readonly vault: BindingsVault,\n    private readonly token: Token,\n    private readonly condition?: ResolutionCondition,\n  ) {}\n\n  /**\n   * @description\n   * Binds the token to the constant value.\n   *\n   * @param value - the value that will be bound to the token.\n   *\n   * @link https://brandi.js.org/reference/binding-types#toconstantvalue\n   */\n  public toConstant(value: Dependency): void {\n    this.vault.set(new ConstantBinding(value), this.token, this.condition);\n  }\n\n  /**\n   * @description\n   * Binds the token to the factory.\n   *\n   * @param creator - the instance creator which the factory will use;\n   * @param [initializer] - optional function called after the instance is created.\n   *\n   * @link https://brandi.js.org/reference/binding-types#tofactorycreator-initializer\n   */\n  public toFactory(\n    creator: Dependency extends AsyncFactory<infer Instance, never[]>\n      ? UnknownCreator<Promise<Instance>>\n      : never,\n    initializer?: Dependency extends AsyncFactory<\n      infer Instance,\n      infer Arguments\n    >\n      ? (instance: Instance, ...args: Arguments) => unknown\n      : never,\n  ): void;\n\n  /**\n   * @description\n   * Binds the token to the factory.\n   *\n   * @param creator - the instance creator which the factory will use;\n   * @param [initializer] - optional function called after the instance is created.\n   *\n   * @link https://brandi.js.org/reference/binding-types#tofactorycreator-initializer\n   */\n  public toFactory(\n    creator: Dependency extends AsyncFactory<infer Instance, never[]>\n      ? UnknownCreator<Instance>\n      : never,\n    initializer: Dependency extends AsyncFactory<\n      infer Instance,\n      infer Arguments\n    >\n      ? (instance: Instance, ...args: Arguments) => Promise<unknown>\n      : never,\n  ): void;\n\n  /**\n   * @description\n   * Binds the token to the factory.\n   *\n   * @param creator - the instance creator which the factory will use;\n   * @param [initializer] - optional function called after the instance is created.\n   *\n   * @link https://brandi.js.org/reference/binding-types#tofactorycreator-initializer\n   */\n  public toFactory<InitializerReturnType>(\n    creator: Dependency extends Factory<infer Instance, never[]>\n      ? Instance extends Promise<unknown>\n        ? never\n        : UnknownCreator<Instance>\n      : never,\n    initializer?: Dependency extends Factory<infer Instance, infer Arguments>\n      ? InitializerReturnType extends Promise<unknown>\n        ? never\n        : (instance: Instance, ...args: Arguments) => InitializerReturnType\n      : never,\n  ): void;\n\n  public toFactory(\n    creator: UnknownCreator,\n    initializer?: FactoryInitializer,\n  ): void {\n    this.vault.set(\n      new FactoryBinding({ creator, initializer }),\n      this.token,\n      this.condition,\n    );\n  }\n\n  /**\n   * @description\n   * Binds the token to an instance in one of the scopes.\n   *\n   * @param creator - the instance creator that will be bound to the token.\n   *\n   * @returns\n   * Scope syntax:\n   *   - `inSingletonScope()`\n   *   - `inTransientScope()`\n   *   - `inContainerScope()`\n   *   - `inResolutionScope()`\n   *\n   * @link https://brandi.js.org/reference/binding-types#toinstancecreator\n   */\n  public toInstance(creator: UnknownCreator<Dependency>): ScopeSyntax {\n    return new ScopeSyntax(this.vault, creator, this.token, this.condition);\n  }\n}\n", "import { Token, TokenType } from '../../pointers';\nimport { ResolutionCondition } from '../../types';\n\nimport { BindingsVault } from '../BindingsVault';\n\nimport { FromSyntax } from './FromSyntax';\nimport { TypeSyntax } from './TypeSyntax';\n\nexport class BindOrUseSyntax {\n  protected static vault(target: BindOrUseSyntax) {\n    return target.vault;\n  }\n\n  constructor(\n    protected vault: BindingsVault,\n    private readonly condition?: ResolutionCondition,\n  ) {}\n\n  /**\n   * @description\n   * Binds the token to an implementation.\n   *\n   * @param token - a token to be bound.\n   *\n   * @returns\n   * Binding Type syntax:\n   *   - `toConstant(value)`\n   *   - `toInstance(creator)`\n   *   - `toFactory(creator, [initializer])`\n   *\n   * @link https://brandi.js.org/reference/container#bindtoken\n   */\n  public bind<T extends Token>(token: T): TypeSyntax<TokenType<T>> {\n    return new TypeSyntax<TokenType<T>>(this.vault, token, this.condition);\n  }\n\n  /**\n   * @description\n   * Uses bindings from a dependency module.\n   *\n   * @param tokens - tokens to be used from a dependency module.\n   * @returns `.from(module)` syntax.\n   *\n   * @link https://brandi.js.org/reference/container#usetokensfrommodule\n   */\n  public use(...tokens: Token[]): FromSyntax {\n    return new FromSyntax(\n      this.vault,\n      tokens,\n      BindOrUseSyntax.vault,\n      this.condition,\n    );\n  }\n}\n", "import { ResolutionCondition } from '../../types';\n\nimport { BindOrUseSyntax } from './BindOrUseSyntax';\n\nexport class WhenSyntax extends BindOrUseSyntax {\n  /**\n   * @description\n   * Creates a conditional binding.\n   *\n   * @param condition - a condition.\n   * @returns `bind` or `use` syntax.\n   *\n   * @link https://brandi.js.org/reference/conditional-bindings\n   */\n  public when(condition: ResolutionCondition): BindOrUseSyntax {\n    return new BindOrUseSyntax(this.vault, condition);\n  }\n}\n", "import { BindingsVault } from './BindingsVault';\nimport { WhenSyntax } from './syntax';\n\nexport class DependencyModule extends WhenSyntax {\n  constructor() {\n    super(new BindingsVault());\n  }\n}\n", "import { Binding } from './bindings';\nimport type { BindingsVault } from './BindingsVault';\n\nexport class ResolutionCache {\n  constructor(\n    public readonly instances = new Map<Binding, unknown>(),\n    public readonly vaults: BindingsVault[] = [],\n  ) {}\n\n  public split(): ResolutionCache {\n    return new ResolutionCache(this.instances, this.vaults.slice());\n  }\n}\n", "import { ResolutionCondition, UnknownCreator } from '../types';\nimport { TokenType, TokenValue } from '../pointers';\nimport { callableRegistry, injectsRegistry, tagsRegistry } from '../registries';\n\nimport {\n  Binding,\n  FactoryInitializer,\n  InstanceBinding,\n  isFactoryBinding,\n  isInstanceBinding,\n  isInstanceContainerScopedBinding,\n  isInstanceResolutionScopedBinding,\n  isInstanceSingletonScopedBinding,\n} from './bindings';\nimport { BindingsVault } from './BindingsVault';\nimport { DependencyModule } from './DependencyModule';\nimport { ResolutionCache } from './ResolutionCache';\n\nexport class Container extends DependencyModule {\n  private snapshot: BindingsVault | null = null;\n\n  /**\n   * @description\n   * Captures (snapshots) the current container state.\n   *\n   * @link https://brandi.js.org/reference/container#capture\n   */\n  public capture?(): void;\n\n  /**\n   * @description\n   * Restores the captured container state.\n   *\n   * @link https://brandi.js.org/reference/container#restore\n   */\n  public restore?(): void;\n\n  constructor() {\n    super();\n\n    if (process.env.NODE_ENV !== 'production') {\n      this.capture = (): void => {\n        this.snapshot = this.vault.copy!();\n      };\n\n      this.restore = (): void => {\n        if (this.snapshot) {\n          this.vault = this.snapshot.copy!();\n        } else {\n          console.error(\n            \"Error: It looks like a trying to restore a non-captured container state. Did you forget to call 'capture()' method?\",\n          );\n        }\n      };\n    }\n  }\n\n  /**\n   * @description\n   * Sets the parent container.\n   *\n   * @param container - a `Container` or `null` that will be set as the parent container.\n   * @returns `this`.\n   *\n   * @link https://brandi.js.org/reference/container#extendcontainer\n   */\n  public extend(container: Container | null): this {\n    this.vault.parent = container === null ? null : container.vault;\n    return this;\n  }\n\n  /**\n   * @description\n   * Creates an unlinked clone of the container.\n   *\n   * @returns `Container`.\n   *\n   * @link https://brandi.js.org/reference/container#clone\n   */\n  public clone(): Container {\n    const container = new Container();\n    container.vault = this.vault.clone();\n    return container;\n  }\n\n  /**\n   * @description\n   * Gets a dependency bound to the token.\n   *\n   * @param token - token for which a dependence will be got.\n   * @returns `TokenType<TokenValue>`.\n   *\n   * @link https://brandi.js.org/reference/container#gettoken\n   */\n  public get<T extends TokenValue>(token: T): TokenType<T>;\n\n  /**\n   * @access package\n   * @deprecated\n   * `conditions` argument is added for internal use.\n   * Use it if you really understand that it is necessary.\n   */\n  public get<T extends TokenValue>(\n    token: T,\n    conditions: ResolutionCondition[],\n  ): TokenType<T>;\n\n  public get<T extends TokenValue>(\n    token: T,\n    conditions?: ResolutionCondition[],\n  ): TokenType<T> {\n    return this.resolveToken(token, conditions) as TokenType<T>;\n  }\n\n  private resolveTokens(\n    tokens: TokenValue[],\n    cache: ResolutionCache,\n    conditions?: ResolutionCondition[],\n    target?: UnknownCreator,\n  ): unknown[] {\n    return tokens.map((token) =>\n      this.resolveToken(token, conditions, target, cache.split()),\n    );\n  }\n\n  private resolveToken(\n    token: TokenValue,\n    conditions?: ResolutionCondition[],\n    target?: UnknownCreator,\n    cache: ResolutionCache = new ResolutionCache(),\n  ): unknown {\n    const binding = this.vault.get(token, cache, conditions, target);\n\n    if (binding) return this.resolveBinding(binding, cache);\n    if (token.__o) return undefined;\n\n    throw new Error(`No matching bindings found for '${token.__d}' token.`);\n  }\n\n  private resolveBinding(binding: Binding, cache: ResolutionCache): unknown {\n    if (isInstanceBinding(binding)) {\n      if (isInstanceSingletonScopedBinding(binding)) {\n        return this.resolveCache(\n          binding,\n          cache,\n          () => binding.cache,\n          (instance) => {\n            // eslint-disable-next-line no-param-reassign\n            binding.cache = instance;\n          },\n        );\n      }\n\n      if (isInstanceContainerScopedBinding(binding)) {\n        return this.resolveCache(\n          binding,\n          cache,\n          () => binding.cache.get(this.vault),\n          (instance) => {\n            binding.cache.set(this.vault, instance);\n          },\n        );\n      }\n\n      if (isInstanceResolutionScopedBinding(binding)) {\n        return this.resolveCache(\n          binding,\n          cache,\n          () => cache.instances.get(binding),\n          (instance) => {\n            cache.instances.set(binding, instance);\n          },\n        );\n      }\n\n      return this.createInstance(binding.impl, cache);\n    }\n\n    if (isFactoryBinding(binding)) {\n      return (...args: unknown[]) => {\n        const instance = this.createInstance(binding.impl.creator, cache);\n\n        return instance instanceof Promise\n          ? instance.then((i) =>\n              Container.resolveInitialization(\n                i,\n                args,\n                binding.impl.initializer,\n              ),\n            )\n          : Container.resolveInitialization(\n              instance,\n              args,\n              binding.impl.initializer,\n            );\n      };\n    }\n\n    return binding.impl;\n  }\n\n  private resolveCache(\n    binding: InstanceBinding,\n    cache: ResolutionCache,\n    getCache: () => unknown,\n    setCache: (instance: unknown) => void,\n  ) {\n    const instanceCache = getCache();\n\n    if (instanceCache !== undefined) return instanceCache;\n\n    const instance = this.createInstance(binding.impl, cache);\n    setCache(instance);\n    return instance;\n  }\n\n  private createInstance(\n    creator: UnknownCreator,\n    cache: ResolutionCache,\n  ): unknown {\n    const parameters = this.getParameters(creator, cache);\n    const isCallable = callableRegistry.get(creator);\n\n    if (isCallable !== undefined) {\n      return isCallable\n        ? // @ts-expect-error: This expression is not callable.\n          creator(...parameters)\n        : // @ts-expect-error: This expression is not constructable.\n          // eslint-disable-next-line new-cap\n          new creator(...parameters);\n    }\n\n    try {\n      // @ts-expect-error: This expression is not callable.\n      const instance = creator(...parameters);\n      callableRegistry.set(creator, true);\n      return instance;\n    } catch {\n      // @ts-expect-error: This expression is not constructable.\n      // eslint-disable-next-line new-cap\n      const instance = new creator(...parameters);\n      callableRegistry.set(creator, false);\n      return instance;\n    }\n  }\n\n  private getParameters(\n    target: UnknownCreator,\n    cache: ResolutionCache,\n  ): unknown[] {\n    const injects = injectsRegistry.get(target);\n\n    if (injects)\n      return this.resolveTokens(\n        injects,\n        cache,\n        tagsRegistry.get(target),\n        target,\n      );\n\n    if (target.length === 0) return [];\n\n    throw new Error(\n      `Missing required 'injected' registration of '${target.name}'`,\n    );\n  }\n\n  private static resolveInitialization<T>(\n    instance: T,\n    args: unknown[],\n    initializer?: FactoryInitializer,\n  ) {\n    const initialization = initializer?.(instance, ...args);\n    return initialization instanceof Promise\n      ? initialization.then(() => instance)\n      : instance;\n  }\n}\n", "import { Container } from './Container';\n\n/**\n * @description\n * Alias for `new Container()`.\n *\n * @example\n * <caption>Example usage of `createContainer()`.</caption>\n *\n * const container = createContainer();\n * console.log(container instanceof Container); // \u2192 true\n *\n * @link https://brandi.js.org/reference/container#createcontainer\n */\nexport const createContainer = () => new Container();\n", "import { DependencyModule } from './DependencyModule';\n\n/**\n * @description\n * Alias for `new DependencyModule()`.\n *\n * @example\n * <caption>Example usage of `createDependencyModule()`.</caption>\n *\n * const dependencyModule = createDependencyModule();\n * console.log(dependencyModule instanceof DependencyModule); // \u2192 true\n *\n * @link https://brandi.js.org/reference/dependency-modules#createdependencymodule\n */\nexport const createDependencyModule = () => new DependencyModule();\n", "import { ToToken, TokenValue } from '../pointers';\nimport { UnknownCreator, UnknownCreatorParameters } from '../types';\nimport { injectsRegistry } from '../registries';\n\ntype ToTokens<T extends unknown[]> = {\n  [K in keyof T]-?: ToToken<T[K]>;\n};\n\n/**\n * @description\n * Registers target injections.\n *\n * @param target - constructor or function whose dependencies will be injected.\n * @param ...tokens - dependency tokens.\n * @returns the `target` first argument.\n *\n * @link https://brandi.js.org/reference/pointers-and-registrators#injectedtarget-tokens\n */\nexport const injected = <T extends UnknownCreator>(\n  target: T,\n  ...tokens: ToTokens<UnknownCreatorParameters<T>> extends TokenValue[]\n    ? ToTokens<UnknownCreatorParameters<T>>\n    : never\n) => {\n  injectsRegistry.set(target, tokens);\n  return target;\n};\n", "import { Tag } from '../pointers';\nimport { UnknownCreator } from '../types';\nimport { tagsRegistry } from '../registries';\n\n/**\n * @description\n * Tags target.\n *\n * @param target - constructor or function that will be tagged.\n * @param ...tags - tags.\n * @returns the `target` first argument.\n *\n * @link https://brandi.js.org/reference/conditional-bindings\n */\nexport const tagged = <T extends UnknownCreator>(\n  target: T,\n  ...tags: Tag[]\n): T => {\n  tagsRegistry.set(target, tags);\n  return target;\n};\n"],
  "mappings": "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",
  "names": []
}
